5-1
実行結果：
Parent() called
Parent() called
Parent() called
Parent(int x = 1) called

コンストラクターは与えられた引数によって適しているものが呼び出されるようにできている。
最初の呼び出しでは、Constructorの引数がないため、Super();が書かれているコンストラクターが呼び出された。
次の呼び出しでは、Constructorが一つ引数を持っているので、Super()が書かれていないConstructorが呼び出される。この時は親クラスの引数のないコンストラクターが呼び出される。これはSuper()と同じである。
その次は、Constructorは二つ引数を持つので、Super();が呼び出される。
最後は三つ引数があるので(x=1)、Super(x);が書かれているConstructorが呼び出され、親クラスでもParent(in x)が呼び出される。このため、実行結果はParent(int x = 1) calledとなった。

5-2
1)A:m1 A:m2 A:m3 
2)B:m1 A:m2 A:m3 
3)C:m1 A:m2 C:m3 
4)C:m1 A:m2 C:m3 

showMessagesは、vオブジェクトのm1, m2, m3メソッドを呼び出す。
1), 2), 3), 4),はそれぞれ、A, B, C, Userオブジェクトを呼び出す。
Aのm関数はそれぞれ,A:m1 A:m2 A:m3 のような結果を追う凛とした。
Bのクラスでは、m1は定義されている通りB:m1をプリントする。m2は親クラスのm2を呼び出す。よってAと同じm2である。m3はなんの定義もないので親クラスの呼び出しをするのでこれもAと同じである。
Cのクラスでは、m1, m3は定義通りC:m1, C:m3をプリントする。m2は親クラスのBのm2を呼び出す。親クラスのm2はまたその親クラスのAのm2を呼び出す。
Userクラスではmの関数は一切定義されていないため、親クラスのメソッドを継承する。よってこれはCと同じ結果になる。

5-3
class XでmethodX()をabstractとしているのに、その子クラスでmethodX()を定義していないのでオーバーライドされておらず、コンパイル時にエラーとなる。

5-4
Prob54では、Y y = new X();として、見かけのクラスYを使って実際のクラスXのオブジェクトを作っている。ここでXobjectはclass XのmethodA()を呼び出すのだが、
Yクラスにオーバーライドされていて、呼び出せずにエラーが出ることになる。
